%header {: // Generated from gen/parser/NatlabParser.all
package natlab;
	 import ast.*;:};
%embed {: // Generated from gen/parser/NatlabParser.all
//// Errors ////////////////////////////////////////////////////////////////

    //list of errors encountered while parsing
    private final java.util.List<String> errors = new java.util.ArrayList<String>();

    public java.util.List<String> getErrors() {
        return java.util.Collections.unmodifiableList(errors);
    }

    public boolean hasError() {
        return !errors.isEmpty();
    }

    //given a symbol, return a canonical string representation of it's position
    private static String getPosString(Symbol token) {
        return getPosString(token.getLine(token.getStart()), token.getColumn(token.getStart()));
    }

    //given a position, return a canonical string representation
    private static String getPosString(int line, int col) {
        return "[" + line + ", " + col + "]";
    }

    //override the default error handling:
    //  1) no writing to stderr
    //  2) no exceptions
    //  3) suggestions based on automatic corrections
    class Events extends Parser.Events {
        public void syntaxError(Symbol token) {
            errors.add(getPosString(token) + "  unexpected token " + Terminals.NAMES[token.getId()]);
        }
        public void scannerError(Scanner.Exception e) {
            errors.add(getPosString(e.line, e.column) + "  scanner error: " + e.getMessage());
        }
        public void unexpectedTokenRemoved(Symbol token) {
            errors.add(getPosString(token) + "  try deleting " + Terminals.NAMES[token.getId()]);
        }
        public void missingTokenInserted(Symbol token) {
            errors.add(getPosString(token) + "  try inserting " + Terminals.NAMES[token.getId()]);
        }
        public void misspelledTokenReplaced(Symbol token) {
            errors.add(getPosString(token) + "  try replacing with " + Terminals.NAMES[token.getId()]);
        }
    }

    //tell handler to use subclass defined above
    { report = new Events(); }
    
    //// Stmt terminators //////////////////////////////////////////////////////

    //return type of statement terminators
    //need this because non-terminals must return symbols
    private static class BooleanFakeSymbol extends Symbol {
        private boolean value;
        BooleanFakeSymbol(boolean value) { this.value = value; }
        Stmt annotateStmt(Stmt stmt) { stmt.setOutputSuppressed(value); return stmt; }
    }

    //// Comments //////////////////////////////////////////////////////////////

    //comment buffer populated by scanner
    //should be non-null, but null is handled gracefully
    private CommentBuffer commentBuffer = null;

    public void setCommentBuffer(CommentBuffer commentBuffer) {
        this.commentBuffer = commentBuffer;
    }

    public CommentBuffer getCommentBuffer() {
        return commentBuffer;
    }

    //attach all comments since last request to provided node
    private <T extends ASTNode> T annotateWithComments(T node) {
        if(node != null && commentBuffer != null) {
            //if the node is a statement, only attach if the statement starts
            //on the same or an earlier line as the comment
            //- otherwise it comments might be bound to too early statements
            if (node instanceof Stmt){
                while(!commentBuffer.isEmpty()
                      && (ASTNode.getLine(commentBuffer.peekComment().getStart())
                          <= ASTNode.getLine(node.getEnd()))){
                    node.addComment(commentBuffer.pollComment()); //add to list
                }
            } else { 
                node.setComments(commentBuffer.pollAllComments());
            }
        }
        return node;
    }
    
    //attach comments to an empty statement -- need the separator symbol, because the
    //empty statement itself seems to have no location information
    private EmptyStmt annotateEmptyStmtWithComments(EmptyStmt node,Symbol location) {
        if(node != null && commentBuffer != null) {
            //if the node is a statement, only attach if the statement ends
            //on the same or a later line as the comment
            //- otherwise comments might be bound to too early statements
            while(!commentBuffer.isEmpty()
                    && (ASTNode.getLine(commentBuffer.peekComment().getStart())
                            <= ASTNode.getLine(location.getEnd()))){
                node.addComment(commentBuffer.pollComment()); //add to list
            }
        }
        return node;
    }
    
    //AST really doesn't like null nodes, but beaver returns null for empty optional lists
    //Create an appropriate empty node to replace the null
    private static <T extends ASTNode> List<T> nullToEmpty(List<T> original) {
        return original == null ? new List<T>() : original;
    }

    //helper for constructing an AST Function node
    //separates stmts from nested functions and attaches comments
    private Function function(List<Name> outParams, Name name, List<Name> inParams, List<HelpComment> comments, List<FunctionOrSignatureOrPropertyAccessOrStmt> body) {
        List<Stmt> stmts = new List<Stmt>();
        List<Function> nestedFunctions = new List<Function>();
        if(body != null) {
            for(Symbol stmtOrFcn : body) {
                if(stmtOrFcn instanceof Stmt) {
                    stmts.add((Stmt) stmtOrFcn);
                } else if(stmtOrFcn instanceof Function) {
                    nestedFunctions.add((Function) stmtOrFcn);
                } else {
                    //NB: programmatic error, not parser error
                    int pos = stmtOrFcn.getStart();
                    int line = Symbol.getLine(pos);
                    int col = Symbol.getColumn(pos);
                    throw new RuntimeException("Symbol in body is neither a Stmt nor a Function: " + getPosString(stmtOrFcn) + "  " + stmtOrFcn);
                }
            }
        }
        return annotateWithComments(new Function(
                nullToEmpty(outParams),
                name,
                nullToEmpty(inParams),
                nullToEmpty(comments),
                stmts,
                nestedFunctions));
    }
    
    //helper for constructing an AST ClassDef node
    //separates properties, methods and events
    private ClassDef classdef(List<Attribute> attr, String name, List<SuperClass> supClass, List<HelpComment> comments, List body) {
        List<Properties> prop = new List<Properties>();
        List<Methods> methods = new List<Methods>();
        List<ClassEvents> events = new List<ClassEvents>();
        
        if(body != null) {
            for(Object obj : body) {
            	Symbol propOrMethodOrEvent = (Symbol)obj;
                if(propOrMethodOrEvent instanceof Properties) {
                    prop.add((Properties) propOrMethodOrEvent);
                } else if(propOrMethodOrEvent instanceof Methods) {
                    methods.add((Methods) propOrMethodOrEvent);
                } else if(propOrMethodOrEvent instanceof ClassEvents) {
                    events.add((ClassEvents) propOrMethodOrEvent);
                } else {
                    //NB: programmatic error, not parser error
                    int pos = propOrMethodOrEvent.getStart();
                    int line = Symbol.getLine(pos);
                    int col = Symbol.getColumn(pos);
                    throw new RuntimeException("Symbol in body is not a Property, a Method, or an Event: " + getPosString(propOrMethodOrEvent) + "  " + propOrMethodOrEvent);
                }
            }
        }
        return new ClassDef(nullToEmpty(attr), name, nullToEmpty(supClass), nullToEmpty(comments), prop, methods, events);
    }
    
    //helper for constructing an AST Methods node
    //separates signatures from functions
    private Methods methods(List<Attribute> attr, List<FunctionOrSignatureOrPropertyAccessOrStmt> body) {
        List<Signature> sign = new List<Signature>();
        List<PropertyAccess> prop = new List<PropertyAccess>();
        List<Function> function = new List<Function>();
        if(body != null) {
            for(Symbol signOrFcn : body) {
                if(signOrFcn instanceof Signature) {
                    sign.add((Signature) signOrFcn);
                } else if(signOrFcn instanceof PropertyAccess) {
                    prop.add((PropertyAccess) signOrFcn);
                } else if(signOrFcn instanceof Function) {
                    function.add((Function) signOrFcn);
                } else {
                    //NB: programmatic error, not parser error
                    int pos = signOrFcn.getStart();
                    int line = Symbol.getLine(pos);
                    int col = Symbol.getColumn(pos);
                    throw new RuntimeException("Symbol in body is not a Signature, a PropertAccess, or a Function: " + getPosString(signOrFcn) + "  " + signOrFcn);
                }
            }
        }
        return new Methods(nullToEmpty(attr), sign, prop, function);
    }
    
    //helper for constructing an AST PropertAccess node
    //separates stmts from nested functions and attaches comments
    private PropertyAccess propertyAccess(List<Name> outParams, String access, String name, List<Name> inParams, List<HelpComment> comments, List<FunctionOrSignatureOrPropertyAccessOrStmt> body) {
        List<Stmt> stmts = new List<Stmt>();
        List<Function> nestedFunctions = new List<Function>();
        if(body != null) {
            for(Symbol stmtOrFcn : body) {
                if(stmtOrFcn instanceof Stmt) {
                    stmts.add((Stmt) stmtOrFcn);
                } else if(stmtOrFcn instanceof Function) {
                    nestedFunctions.add((Function) stmtOrFcn);
                } else {
                    //NB: programmatic error, not parser error
                    int pos = stmtOrFcn.getStart();
                    int line = Symbol.getLine(pos);
                    int col = Symbol.getColumn(pos);
                    throw new RuntimeException("Symbol in body is neither a Stmt nor a Function: " + getPosString(stmtOrFcn) + "  " + stmtOrFcn);
                }
            }
        }
        return annotateWithComments(new PropertyAccess(
                nullToEmpty(outParams),
                access,
                name,
                nullToEmpty(inParams),
                nullToEmpty(comments),
                stmts,
                nestedFunctions));
    }:};
%terminals LINE_TERMINATOR;
%terminals FUNCTION;
%terminals ASSIGN;
%terminals END;
%terminals LPAREN;
%terminals RPAREN;
%terminals LSQUARE;
%terminals RSQUARE;
%terminals NOT;
%terminals COMMA;
%terminals CLASSDEF;
%terminals IDENTIFIER;
%terminals LT;
%terminals AND;
%terminals PROPERTIES;
%terminals METHODS;
%terminals EVENTS;
%terminals DOT;
%terminals HELP_COMMENT;
%terminals BRACKET_HELP_COMMENT;
%terminals GLOBAL;
%terminals PERSISTENT;
%terminals SHELL_COMMAND;
%terminals TRY;
%terminals CATCH;
%terminals BREAK;
%terminals CONTINUE;
%terminals RETURN;
%terminals WHILE;
%terminals FOR;
%terminals PARFOR;
%terminals SWITCH;
%terminals CASE;
%terminals OTHERWISE;
%terminals IF;
%terminals ELSEIF;
%terminals ELSE;
%terminals SEMICOLON;
%terminals SEMICOLON_LINE_TERMINATOR;
%terminals COMMA_LINE_TERMINATOR;
%terminals AT;
%terminals SHORTOR;
%terminals SHORTAND;
%terminals OR;
%terminals EQ;
%terminals NE;
%terminals GT;
%terminals LE;
%terminals GE;
%terminals COLON;
%terminals PLUS;
%terminals MINUS;
%terminals MTIMES;
%terminals ETIMES;
%terminals MDIV;
%terminals EDIV;
%terminals MLDIV;
%terminals ELDIV;
%terminals MPOW;
%terminals EPOW;
%terminals ARRAYTRANSPOSE;
%terminals MTRANSPOSE;
%terminals LCURLY;
%terminals RCURLY;
%terminals INT_NUMBER;
%terminals IM_INT_NUMBER;
%terminals FP_NUMBER;
%terminals IM_FP_NUMBER;
%terminals STRING;
%terminals COMMENT;
%terminals ELLIPSIS_COMMENT;
%terminals BRACKET_COMMENT;
%typeof function_signature = "Signature";
%typeof cell_access = "Expr";
%typeof stmt_or_function = "FunctionOrSignatureOrPropertyAccessOrStmt";
%typeof stmt_or_function_opt_list = "List";
%typeof stmt_or_function_list = "List";
%typeof logic_expr_and = "Expr";
%typeof stmt_body_before_comments = "Stmt";
%typeof prefix_arg = "Expr";
%typeof program = "Program";
%typeof for_assign = "AssignStmt";
%typeof stmt_body = "Stmt";
%typeof logic_arg_shortand = "Expr";
%typeof else_if_clause = "IfBlock";
%typeof else_if_clause_list = "List";
%typeof cell_array = "ASTNode";
%typeof function_seq = "FunctionList";
%typeof function = "Function";
%typeof function_list = "List";
%typeof if_clause = "IfBlock";
%typeof logic_arg_and = "Expr";
%typeof prefix_expr = "Expr";
%typeof superclass_list = "List";
%typeof primary_expr = "Expr";
%typeof element = "Expr";
%typeof class_body = "ClassBody";
%typeof class_body_opt_list = "List";
%typeof class_body_list = "List";
%typeof methods_body = "FunctionOrSignatureOrPropertyAccessOrStmt";
%typeof methods_body_opt_list = "List";
%typeof methods_body_list = "List";
%typeof logic_expr_shortor = "Expr";
%typeof binary_expr_times_div = "Expr";
%typeof output_params = "List";
%typeof colon_arg = "Expr";
%typeof program_before_comments = "Program";
%typeof stmt_separator_list = "List";
%typeof script = "Script";
%typeof pow_expr = "Expr";
%typeof binary_arg_times_div = "Expr";
%typeof otherTerminal = "ASTNode";
%typeof pow_arg = "Expr";
%typeof input_params = "List";
%typeof binary_expr_plus_minus = "Expr";
%typeof switch_case = "SwitchCaseBlock";
%typeof switch_case_list = "List";
%typeof name = "Name";
%typeof name_list = "List";
%typeof if_statement = "IfStmt";
%typeof properties_body = "Property";
%typeof properties_body_opt_list = "List";
%typeof properties_body_list = "List";
%typeof properties_block = "Properties";
%typeof prefix_exp_expr = "Expr";
%typeof access = "Expr";
%typeof optional_row_list = "List";
%typeof events_body = "Event";
%typeof events_body_opt_list = "List";
%typeof events_body_list = "List";
%typeof postfix_expr = "Expr";
%typeof function_body = "Function";
%typeof switch_statement = "SwitchStmt";
%typeof matrix = "MatrixExpr";
%typeof prefix_exp_arg = "Expr";
%typeof class_def = "ClassDef";
%typeof logic_expr_eq_ne = "Expr";
%typeof property_access = "PropertyAccess";
%typeof last_help_comment = "HelpComment";
%typeof literal = "LiteralExpr";
%typeof colon_expr = "Expr";
%typeof postfix_arg = "Expr";
%typeof last_stmt = "Stmt";
%typeof element_list = "List";
%typeof logic_expr_lt_gt_le_ge = "Expr";
%typeof arg = "Expr";
%typeof logic_arg_or = "Expr";
%typeof primary_arg = "Expr";
%typeof default_case = "DefaultCaseBlock";
%typeof logic_arg_eq_ne = "Expr";
%typeof methods_block = "Methods";
%typeof expr = "Expr";
%typeof logic_arg_lt_gt_le_ge = "Expr";
%typeof attribute = "Attribute";
%typeof row = "Row";
%typeof binary_arg_plus_minus = "Expr";
%typeof stmt_separator = "BooleanFakeSymbol";
%typeof stmt_seq = "List";
%typeof stmt_separator_opt_list = "List";
%typeof help_comment = "HelpComment";
%typeof help_comment_opt_list = "List";
%typeof help_comment_list = "List";
%typeof help_comment_body = "HelpComment";
%typeof events_block = "ClassEvents";
%typeof param_list = "List";
%typeof logic_expr_shortand = "Expr";
%typeof arg_list = "List";
%typeof row_list = "List";
%typeof attribute_list = "List";
%typeof row_separator = "ASTNode";
%typeof attributes = "List";
%typeof attributes_opt = "List";
%typeof logic_expr_or = "Expr";
%typeof stmt = "Stmt";
%typeof stmt_list = "List";
%typeof else_clause = "ElseBlock";
%typeof logic_arg_shortor = "Expr";
%goal program;
program =
    program_before_comments.p {: return annotateWithComments(p);:}
  ;
program_before_comments =
    script.s {: return s;:}

  | function_seq.f {: return f;:}

  | class_def.c {: return c;:}

  | {: return new Script();:}

  | otherTerminal.otherTerminal {: return new Script();:}
  ;
script =
    stmt_list.stmts last_stmt.s {: return new Script(new List<HelpComment>(), stmts.add(s));:}

  | last_stmt.s {: return new Script(new List<HelpComment>(), new List<Stmt>().add(s));:}

  | help_comment_list.comments stmt_list.stmts last_stmt.s {: return new Script(comments, stmts.add(s));:}

  | help_comment_list.comments last_stmt.s {: return new Script(comments, new List<Stmt>().add(s));:}

  | help_comment_list.comments last_help_comment.c {: return new Script(comments.add(c), new List<Stmt>());:}

  | last_help_comment.c {: return new Script(new List<HelpComment>().add(c), new List<Stmt>());:}
  ;
function_seq =
    function_list.functions {: return new FunctionList(functions);:}
  ;
function =
    function_body.f LINE_TERMINATOR.LINE_TERMINATOR* {: return f;:}
  ;
function_body =
    FUNCTION.FUNCTION output_params.out ASSIGN.ASSIGN name.name stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END {: return function(out, name, new List(), comments, body);:}

  | FUNCTION.FUNCTION output_params.out ASSIGN.ASSIGN name.name input_params.in stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END {: return function(out, name, in, comments, body);:}

  | FUNCTION.FUNCTION name.name stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END {: return function(null, name, new List(), comments, body);:}

  | FUNCTION.FUNCTION name.name input_params.in stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END {: return function(null, name, in, comments, body);:}
  ;
input_params =
    LPAREN.LPAREN RPAREN.RPAREN {: return new List<Name>();:}

  | LPAREN.LPAREN param_list.l RPAREN.RPAREN {: return l;:}
  ;
output_params =
    LSQUARE.LSQUARE RSQUARE.RSQUARE {: return new List<Name>();:}

  | LSQUARE.LSQUARE param_list.l RSQUARE.RSQUARE {: return l;:}

  | name.p {: return new List<Name>().add(p);:}
  ;
param_list =
    name.p {: return new List<Name>().add(p);:}

  | NOT.NOT {: return new List<Name>().add(new Name("~"));:}

  | param_list.l COMMA.COMMA name.p {: return l.add(p);:}

  | param_list.l COMMA.COMMA NOT.NOT {: return l.add(new Name("~"));:}
  ;
stmt_or_function =
    stmt.s {: return s;:}

  | function_body.f {: return f;:}
  ;
class_def =
    CLASSDEF.CLASSDEF attributes_opt.attr IDENTIFIER.name stmt_separator_list.stmt_separator_list help_comment_opt_list.comments class_body_opt_list.body END.END {: return classdef(attr, ((String)name.value), null, comments, body);:}

  | CLASSDEF.CLASSDEF attributes_opt.attr IDENTIFIER.name LT.LT superclass_list.superclasses stmt_separator_list.stmt_separator_list help_comment_opt_list.comments class_body_opt_list.body END.END {: return classdef(attr, ((String)name.value), superclasses, comments, body);:}
  ;
attributes =
    LPAREN.LPAREN attribute_list.a RPAREN.RPAREN {: return a;:}
  ;
attribute_list =
    attribute.a {: return new List<Attribute>().add(a);:}

  | attribute_list.l COMMA.COMMA attribute.a {: return l.add(a);:}
  ;
attribute =
    IDENTIFIER.key {: return new Attribute(((String)key.value), new NameExpr(new Name("true")));:}

  | NOT.NOT IDENTIFIER.key {: return new Attribute(((String)key.value), new NameExpr(new Name("false")));:}

  | IDENTIFIER.key ASSIGN.ASSIGN expr.value {: return new Attribute(((String)key.value), value);:}
  ;
superclass_list =
    IDENTIFIER.name {: return new List<SuperClass>().add(new SuperClass(((String)name.value)));:}

  | superclass_list.l AND.AND IDENTIFIER.name {: return l.add(new SuperClass(((String)name.value)));:}
  ;
class_body =
    properties_block.p stmt_separator_opt_list.stmt_separator_opt_list {: return p;:}

  | methods_block.m stmt_separator_opt_list.stmt_separator_opt_list {: return m;:}

  | events_block.e stmt_separator_opt_list.stmt_separator_opt_list {: return e;:}
  ;
properties_block =
    PROPERTIES.PROPERTIES stmt_separator_list.stmt_separator_list properties_body_opt_list.body END.END {: return new Properties(nullToEmpty(new List()), nullToEmpty(body));:}

  | PROPERTIES.PROPERTIES attributes.attr stmt_separator_list.stmt_separator_list properties_body_opt_list.body END.END {: return new Properties(nullToEmpty(attr), nullToEmpty(body));:}
  ;
methods_block =
    METHODS.METHODS stmt_separator_list.stmt_separator_list methods_body_opt_list.body END.END {: return methods(new List(), body);:}

  | METHODS.METHODS attributes.attr stmt_separator_list.stmt_separator_list methods_body_opt_list.body END.END {: return methods(attr, body);:}
  ;
events_block =
    EVENTS.EVENTS stmt_separator_list.stmt_separator_list events_body_opt_list.body END.END {: return new ClassEvents(nullToEmpty(new List()), body);:}

  | EVENTS.EVENTS attributes.attr stmt_separator_list.stmt_separator_list events_body_opt_list.body END.END {: return new ClassEvents(nullToEmpty(attr), body);:}
  ;
properties_body =
    IDENTIFIER.name stmt_separator_list.stmt_separator_list {: return new Property(((String)name.value), new MatrixExpr());:}

  | IDENTIFIER.name ASSIGN.ASSIGN expr.value stmt_separator_list.stmt_separator_list {: return new Property(((String)name.value), value);:}
  ;
methods_body =
    function.f {: return f;:}

  | function_signature.s {: return s;:}

  | property_access.p {: return p;:}
  ;
function_signature =
    IDENTIFIER.name stmt_separator_list.stmt_separator_list {: return new Signature(new List<Name>(), ((String)name.value), new List());:}

  | IDENTIFIER.name input_params.in stmt_separator_list.stmt_separator_list {: return new Signature(new List<Name>(), ((String)name.value), in);:}

  | output_params.out ASSIGN.ASSIGN IDENTIFIER.name stmt_separator_list.stmt_separator_list {: return new Signature(out, ((String)name.value), new List());:}

  | output_params.out ASSIGN.ASSIGN IDENTIFIER.name input_params.in stmt_separator_list.stmt_separator_list {: return new Signature(out, ((String)name.value), in);:}
  ;
property_access =
    FUNCTION.FUNCTION output_params.out ASSIGN.ASSIGN IDENTIFIER.acc DOT.DOT IDENTIFIER.name stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END stmt_separator_list.stmt_separator_list {: return propertyAccess(out, ((String)acc.value), ((String)name.value), new List(), comments, body);:}

  | FUNCTION.FUNCTION output_params.out ASSIGN.ASSIGN IDENTIFIER.acc DOT.DOT IDENTIFIER.name input_params.in stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END stmt_separator_list.stmt_separator_list {: return propertyAccess(out, ((String)acc.value), ((String)name.value), in, comments, body);:}

  | FUNCTION.FUNCTION IDENTIFIER.acc DOT.DOT IDENTIFIER.name stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END stmt_separator_list.stmt_separator_list {: return propertyAccess(null, ((String)acc.value), ((String)name.value), new List(), comments, body);:}

  | FUNCTION.FUNCTION IDENTIFIER.acc DOT.DOT IDENTIFIER.name input_params.in stmt_separator.stmt_separator help_comment_opt_list.comments stmt_or_function_opt_list.body END.END stmt_separator_list.stmt_separator_list {: return propertyAccess(null, ((String)acc.value), ((String)name.value), in, comments, body);:}
  ;
events_body =
    IDENTIFIER.name stmt_separator_list.stmt_separator_list {: return new Event(((String)name.value));:}
  ;
last_help_comment =
    help_comment.c {: return c;:}

  | help_comment_body.c {: return c;:}
  ;
help_comment =
    help_comment_body.c LINE_TERMINATOR.LINE_TERMINATOR {: return c;:}
  ;
help_comment_body =
    HELP_COMMENT.c {: return new OneLineHelpComment(((String)c.value));:}

  | BRACKET_HELP_COMMENT.c {: return new MultiLineHelpComment(((String)c.value));:}
  ;
stmt_seq =
    stmt_list.stmts {: return stmts;:}

  | {: return new List<Stmt>();:}
  ;
last_stmt =
    stmt_body.s {: return s;:}

  | stmt.s {: return s;:}
  ;
stmt =
    stmt_body.s stmt_separator.sep {: return sep.annotateStmt(s);:}

  | stmt_separator.sep {: return annotateEmptyStmtWithComments((EmptyStmt)sep.annotateStmt(new EmptyStmt()),sep);:}
  ;
stmt_body =
    stmt_body_before_comments.s {: return annotateWithComments(s);:}
  ;
stmt_body_before_comments =
    expr.e {: return new ExprStmt(e);:}

  | expr.lhs ASSIGN.ASSIGN expr.rhs {: return new AssignStmt(lhs, rhs);:}

  | GLOBAL.GLOBAL name_list.names {: return new GlobalStmt(names);:}

  | PERSISTENT.PERSISTENT name_list.names {: return new PersistentStmt(names);:}

  | SHELL_COMMAND.c {: return new ShellCommandStmt(((String)c.value));:}

  | TRY.TRY stmt_separator.stmt_separator stmt_seq.tl END.END {: return new TryStmt(tl, new List());:}

  | TRY.TRY stmt_separator.stmt_separator stmt_seq.tl CATCH.CATCH stmt_separator.stmt_separator_ stmt_seq.cl END.END {: return new TryStmt(tl, cl);:}

  | switch_statement.s {: return s;:}

  | if_statement.s {: return s;:}

  | BREAK.BREAK {: return new BreakStmt();:}

  | CONTINUE.CONTINUE {: return new ContinueStmt();:}

  | RETURN.RETURN {: return new ReturnStmt();:}

  | WHILE.WHILE expr.e stmt_separator.stmt_separator stmt_seq.l END.END {: return new WhileStmt(e, l);:}

  | FOR.FOR for_assign.a stmt_separator.stmt_separator stmt_seq.l END.END {: return new ForStmt(a, l, false);:}

  | PARFOR.PARFOR for_assign.a stmt_separator.stmt_separator stmt_seq.l END.END {: return new ForStmt(a, l, true);:}
  ;
switch_statement =
    SWITCH.SWITCH expr.e stmt_separator.stmt_separator END.END {: return new SwitchStmt(e, new List<SwitchCaseBlock>(), new Opt<DefaultCaseBlock>());:}

  | SWITCH.SWITCH expr.e stmt_separator.stmt_separator default_case.d END.END {: return new SwitchStmt(e, new List<SwitchCaseBlock>(), new Opt<DefaultCaseBlock>(d));:}

  | SWITCH.SWITCH expr.e stmt_separator.stmt_separator switch_case_list.s END.END {: return new SwitchStmt(e, s, new Opt<DefaultCaseBlock>());:}

  | SWITCH.SWITCH expr.e stmt_separator.stmt_separator switch_case_list.s default_case.d END.END {: return new SwitchStmt(e, s, new Opt<DefaultCaseBlock>(d));:}
  ;
switch_case =
    CASE.CASE expr.e stmt_separator.stmt_separator stmt_seq.l {: return new SwitchCaseBlock(e, l);:}
  ;
default_case =
    OTHERWISE.OTHERWISE stmt_separator.stmt_separator stmt_seq.l {: return new DefaultCaseBlock(l);:}
  ;
if_statement =
    if_clause.i END.END {: return new IfStmt(new List<IfBlock>().add(i), new Opt<ElseBlock>());:}

  | if_clause.i else_clause.els END.END {: return new IfStmt(new List<IfBlock>().add(i), new Opt<ElseBlock>(els));:}

  | if_clause.i else_if_clause_list.elseif END.END {: List<IfBlock> ifBlocks = elseif;
            ifBlocks.insertChild(i, 0);
            return new IfStmt(ifBlocks, new Opt<ElseBlock>());:}

  | if_clause.i else_if_clause_list.elseif else_clause.els END.END {: List<IfBlock> ifBlocks = elseif;
            ifBlocks.insertChild(i, 0);
            return new IfStmt(ifBlocks, new Opt<ElseBlock>(els));:}
  ;
if_clause =
    IF.IF expr.e stmt_separator.stmt_separator stmt_seq.l {: return new IfBlock(e, l);:}
  ;
else_if_clause =
    ELSEIF.ELSEIF expr.e stmt_separator.stmt_separator stmt_seq.l {: return new IfBlock(e, l);:}
  ;
else_clause =
    ELSE.ELSE stmt_separator.stmt_separator stmt_seq.l {: return new ElseBlock(l);:}
  ;
stmt_separator =
    LINE_TERMINATOR.LINE_TERMINATOR {: return new BooleanFakeSymbol(false);:}

  | SEMICOLON.SEMICOLON {: return new BooleanFakeSymbol(true);:}

  | SEMICOLON_LINE_TERMINATOR.SEMICOLON_LINE_TERMINATOR {: return new BooleanFakeSymbol(true);:}

  | COMMA.COMMA {: return new BooleanFakeSymbol(false);:}

  | COMMA_LINE_TERMINATOR.COMMA_LINE_TERMINATOR {: return new BooleanFakeSymbol(false);:}
  ;
stmt_separator_opt_list =
    {: return new List();:}

  | stmt_separator_list.n {: return n;:}
  ;
stmt_separator_list =
    stmt_separator.n {: return new List();:}

  | stmt_separator_list.l stmt_separator.n {: return l;:}
  ;
for_assign =
    name.lhs ASSIGN.ASSIGN expr.rhs {: return new AssignStmt(new NameExpr(lhs), rhs);:}

  | LPAREN.LPAREN name.lhs ASSIGN.ASSIGN expr.rhs RPAREN.RPAREN {: return new AssignStmt(new NameExpr(lhs), rhs);:}
  ;
name =
    IDENTIFIER.id {: return new Name(((String)id.value));:}
  ;
expr =
    logic_expr_shortor.l {: return l;:}

  | AT.AT input_params.params expr.body {: return new LambdaExpr(params, body);:}
  ;
logic_expr_shortor =
    logic_expr_shortand.e {: return e;:}

  | logic_expr_shortor.e1 SHORTOR.SHORTOR logic_expr_shortand.e2 {: return new ShortCircuitOrExpr(e1, e2);:}
  ;
logic_expr_shortand =
    logic_expr_or.e {: return e;:}

  | logic_expr_shortand.e1 SHORTAND.SHORTAND logic_expr_or.e2 {: return new ShortCircuitAndExpr(e1, e2);:}
  ;
logic_expr_or =
    logic_expr_and.e {: return e;:}

  | logic_expr_or.e1 OR.OR logic_expr_and.e2 {: return new OrExpr(e1, e2);:}
  ;
logic_expr_and =
    logic_expr_eq_ne.e {: return e;:}

  | logic_expr_and.e1 AND.AND logic_expr_eq_ne.e2 {: return new AndExpr(e1, e2);:}
  ;
logic_expr_eq_ne =
    logic_expr_lt_gt_le_ge.e {: return e;:}

  | logic_expr_eq_ne.e1 EQ.EQ logic_expr_lt_gt_le_ge.e2 {: return new EQExpr(e1, e2);:}

  | logic_expr_eq_ne.e1 NE.NE logic_expr_lt_gt_le_ge.e2 {: return new NEExpr(e1, e2);:}
  ;
logic_expr_lt_gt_le_ge =
    colon_expr.e {: return e;:}

  | logic_expr_lt_gt_le_ge.e1 LT.LT colon_expr.e2 {: return new LTExpr(e1, e2);:}

  | logic_expr_lt_gt_le_ge.e1 GT.GT colon_expr.e2 {: return new GTExpr(e1, e2);:}

  | logic_expr_lt_gt_le_ge.e1 LE.LE colon_expr.e2 {: return new LEExpr(e1, e2);:}

  | logic_expr_lt_gt_le_ge.e1 GE.GE colon_expr.e2 {: return new GEExpr(e1, e2);:}
  ;
colon_expr =
    binary_expr_plus_minus.e {: return e;:}

  | binary_expr_plus_minus.e1 COLON.COLON binary_expr_plus_minus.e3 {: return new RangeExpr(e1, new Opt(), e3);:}

  | binary_expr_plus_minus.e1 COLON.COLON binary_expr_plus_minus.e2 COLON.COLON_ binary_expr_plus_minus.e3 {: return new RangeExpr(e1, new Opt(e2), e3);:}
  ;
binary_expr_plus_minus =
    binary_expr_times_div.e {: return e;:}

  | binary_expr_plus_minus.e1 PLUS.PLUS binary_expr_times_div.e2 {: return new PlusExpr(e1, e2);:}

  | binary_expr_plus_minus.e1 MINUS.MINUS binary_expr_times_div.e2 {: return new MinusExpr(e1, e2);:}
  ;
binary_expr_times_div =
    prefix_expr.e {: return e;:}

  | binary_expr_times_div.e1 MTIMES.MTIMES prefix_expr.e2 {: return new MTimesExpr(e1, e2);:}

  | binary_expr_times_div.e1 ETIMES.ETIMES prefix_expr.e2 {: return new ETimesExpr(e1, e2);:}

  | binary_expr_times_div.e1 MDIV.MDIV prefix_expr.e2 {: return new MDivExpr(e1, e2);:}

  | binary_expr_times_div.e1 EDIV.EDIV prefix_expr.e2 {: return new EDivExpr(e1, e2);:}

  | binary_expr_times_div.e1 MLDIV.MLDIV prefix_expr.e2 {: return new MLDivExpr(e1, e2);:}

  | binary_expr_times_div.e1 ELDIV.ELDIV prefix_expr.e2 {: return new ELDivExpr(e1, e2);:}
  ;
prefix_expr =
    pow_expr.e {: return e;:}

  | NOT.NOT prefix_expr.e {: return new NotExpr(e);:}

  | PLUS.PLUS prefix_expr.e {: return new UPlusExpr(e);:}

  | MINUS.MINUS prefix_expr.e {: return new UMinusExpr(e);:}
  ;
pow_expr =
    postfix_expr.e {: return e;:}

  | pow_expr.e1 MPOW.MPOW prefix_exp_expr.e2 {: return new MPowExpr(e1, e2);:}

  | pow_expr.e1 EPOW.EPOW prefix_exp_expr.e2 {: return new EPowExpr(e1, e2);:}
  ;
prefix_exp_expr =
    postfix_expr.e {: return e;:}

  | NOT.NOT prefix_exp_expr.e {: return new NotExpr(e);:}

  | PLUS.PLUS prefix_exp_expr.e {: return new UPlusExpr(e);:}

  | MINUS.MINUS prefix_exp_expr.e {: return new UMinusExpr(e);:}
  ;
postfix_expr =
    primary_expr.e {: return e;:}

  | postfix_expr.e ARRAYTRANSPOSE.ARRAYTRANSPOSE {: return new ArrayTransposeExpr(e);:}

  | postfix_expr.e MTRANSPOSE.MTRANSPOSE {: return new MTransposeExpr(e);:}
  ;
primary_expr =
    literal.l {: return l;:}

  | LPAREN.LPAREN expr.e RPAREN.RPAREN {: return e;:}

  | matrix.m {: return m;:}

  | cell_array.c {: return c;:}

  | access.a {: return a;:}

  | AT.AT name.name {: return new FunctionHandleExpr(name);:}
  ;
access =
    cell_access.c {: return c;:}

  | cell_access.c LPAREN.LPAREN RPAREN.RPAREN {: return new ParameterizedExpr(c, new List<Expr>());:}

  | cell_access.c LPAREN.LPAREN arg_list.l RPAREN.RPAREN {: return new ParameterizedExpr(c, l);:}
  ;
cell_access =
    name.n {: return new NameExpr(n);:}

  | name.f AT.AT name.c {: return new SuperClassMethodExpr(f, c);:}

  | cell_access.v LCURLY.LCURLY arg_list.l RCURLY.RCURLY {: return new CellIndexExpr(v, l);:}

  | access.v DOT.DOT name.n {: return new DotExpr(v, n);:}
  ;
literal =
    INT_NUMBER.i {: return new IntLiteralExpr(new DecIntNumericLiteralValue(((String)i.value)));:}

  | IM_INT_NUMBER.i {: return new IntLiteralExpr(new DecIntNumericLiteralValue(((String)i.value), true));:}

  | FP_NUMBER.f {: return new FPLiteralExpr(new FPNumericLiteralValue(((String)f.value).replaceAll("[Dd]", "e")));:}

  | IM_FP_NUMBER.f {: return new FPLiteralExpr(new FPNumericLiteralValue(((String)f.value).replaceAll("[Dd]", "e"), true));:}

  | STRING.s {: return new StringLiteralExpr(((String)s.value));:}
  ;
matrix =
    LSQUARE.LSQUARE optional_row_list.l RSQUARE.RSQUARE {: return new MatrixExpr(l);:}
  ;
cell_array =
    LCURLY.LCURLY optional_row_list.l RCURLY.RCURLY {: return new CellArrayExpr(l);:}
  ;
optional_row_list =
    {: return new List<Row>();:}

  | row_separator.row_separator {: return new List<Row>();:}

  | row_list.l {: return l;:}

  | row_list.l row_separator.row_separator {: return l;:}
  ;
row_list =
    row.r {: return new List<Row>().add(r);:}

  | row_list.l row_separator.row_separator row.r {: return l.add(r);:}
  ;
row =
    element_list.l {: return new Row(l);:}

  | element_list.l COMMA.COMMA {: return new Row(l);:}
  ;
row_separator =
    LINE_TERMINATOR.LINE_TERMINATOR 
  | SEMICOLON.SEMICOLON 
  | SEMICOLON_LINE_TERMINATOR.SEMICOLON_LINE_TERMINATOR 
  | COMMA_LINE_TERMINATOR.COMMA_LINE_TERMINATOR   ;
element_list =
    element.e {: return new List<Expr>().add(e);:}

  | element_list.l COMMA.COMMA element.e {: return l.add(e);:}
  ;
element =
    expr.e {: return e;:}

  | NOT.NOT {: return new NameExpr(new Name("~"));:}
  ;
arg_list =
    arg.a {: return new List<Expr>().add(a);:}

  | arg_list.l COMMA.COMMA arg.a {: return l.add(a);:}
  ;
arg =
    logic_arg_shortor.l {: return l;:}

  | AT.AT input_params.params arg.body {: return new LambdaExpr(params, body);:}

  | COLON.c {: return new ColonExpr();:}
  ;
logic_arg_shortor =
    logic_arg_shortand.e {: return e;:}

  | logic_arg_shortor.e1 SHORTOR.SHORTOR logic_arg_shortand.e2 {: return new ShortCircuitOrExpr(e1, e2);:}
  ;
logic_arg_shortand =
    logic_arg_or.e {: return e;:}

  | logic_arg_shortand.e1 SHORTAND.SHORTAND logic_arg_or.e2 {: return new ShortCircuitAndExpr(e1, e2);:}
  ;
logic_arg_or =
    logic_arg_and.e {: return e;:}

  | logic_arg_or.e1 OR.OR logic_arg_and.e2 {: return new OrExpr(e1, e2);:}
  ;
logic_arg_and =
    logic_arg_eq_ne.e {: return e;:}

  | logic_arg_and.e1 AND.AND logic_arg_eq_ne.e2 {: return new AndExpr(e1, e2);:}
  ;
logic_arg_eq_ne =
    logic_arg_lt_gt_le_ge.e {: return e;:}

  | logic_arg_eq_ne.e1 EQ.EQ logic_arg_lt_gt_le_ge.e2 {: return new EQExpr(e1, e2);:}

  | logic_arg_eq_ne.e1 NE.NE logic_arg_lt_gt_le_ge.e2 {: return new NEExpr(e1, e2);:}
  ;
logic_arg_lt_gt_le_ge =
    colon_arg.e {: return e;:}

  | logic_arg_lt_gt_le_ge.e1 LT.LT colon_arg.e2 {: return new LTExpr(e1, e2);:}

  | logic_arg_lt_gt_le_ge.e1 GT.GT colon_arg.e2 {: return new GTExpr(e1, e2);:}

  | logic_arg_lt_gt_le_ge.e1 LE.LE colon_arg.e2 {: return new LEExpr(e1, e2);:}

  | logic_arg_lt_gt_le_ge.e1 GE.GE colon_arg.e2 {: return new GEExpr(e1, e2);:}
  ;
colon_arg =
    binary_arg_plus_minus.e {: return e;:}

  | binary_arg_plus_minus.e1 COLON.COLON binary_arg_plus_minus.e3 {: return new RangeExpr(e1, new Opt(), e3);:}

  | binary_arg_plus_minus.e1 COLON.COLON binary_arg_plus_minus.e2 COLON.COLON_ binary_arg_plus_minus.e3 {: return new RangeExpr(e1, new Opt(e2), e3);:}
  ;
binary_arg_plus_minus =
    binary_arg_times_div.e {: return e;:}

  | binary_arg_plus_minus.e1 PLUS.PLUS binary_arg_times_div.e2 {: return new PlusExpr(e1, e2);:}

  | binary_arg_plus_minus.e1 MINUS.MINUS binary_arg_times_div.e2 {: return new MinusExpr(e1, e2);:}
  ;
binary_arg_times_div =
    prefix_arg.e {: return e;:}

  | binary_arg_times_div.e1 MTIMES.MTIMES prefix_arg.e2 {: return new MTimesExpr(e1, e2);:}

  | binary_arg_times_div.e1 ETIMES.ETIMES prefix_arg.e2 {: return new ETimesExpr(e1, e2);:}

  | binary_arg_times_div.e1 MDIV.MDIV prefix_arg.e2 {: return new MDivExpr(e1, e2);:}

  | binary_arg_times_div.e1 EDIV.EDIV prefix_arg.e2 {: return new EDivExpr(e1, e2);:}

  | binary_arg_times_div.e1 MLDIV.MLDIV prefix_arg.e2 {: return new MLDivExpr(e1, e2);:}

  | binary_arg_times_div.e1 ELDIV.ELDIV prefix_arg.e2 {: return new ELDivExpr(e1, e2);:}
  ;
prefix_arg =
    pow_arg.e {: return e;:}

  | NOT.NOT prefix_arg.e {: return new NotExpr(e);:}

  | PLUS.PLUS prefix_arg.e {: return new UPlusExpr(e);:}

  | MINUS.MINUS prefix_arg.e {: return new UMinusExpr(e);:}
  ;
pow_arg =
    postfix_arg.e {: return e;:}

  | pow_arg.e1 MPOW.MPOW prefix_exp_arg.e2 {: return new MPowExpr(e1, e2);:}

  | pow_arg.e1 EPOW.EPOW prefix_exp_arg.e2 {: return new EPowExpr(e1, e2);:}
  ;
prefix_exp_arg =
    postfix_arg.e {: return e;:}

  | NOT.NOT prefix_exp_arg.e {: return new NotExpr(e);:}

  | PLUS.PLUS prefix_exp_arg.e {: return new UPlusExpr(e);:}

  | MINUS.MINUS prefix_exp_arg.e {: return new UMinusExpr(e);:}
  ;
postfix_arg =
    primary_arg.e {: return e;:}

  | postfix_arg.e ARRAYTRANSPOSE.ARRAYTRANSPOSE {: return new ArrayTransposeExpr(e);:}

  | postfix_arg.e MTRANSPOSE.MTRANSPOSE {: return new MTransposeExpr(e);:}
  ;
primary_arg =
    literal.l {: return l;:}

  | LPAREN.LPAREN arg.a RPAREN.RPAREN {: return a;:}

  | matrix.m {: return m;:}

  | cell_array.c {: return c;:}

  | access.a {: return a;:}

  | AT.AT name.name {: return new FunctionHandleExpr(name);:}

  | END.END {: return new EndExpr();:}
  ;
otherTerminal =
    PARFOR.PARFOR 
  | COMMENT.COMMENT 
  | ELLIPSIS_COMMENT.ELLIPSIS_COMMENT 
  | BRACKET_COMMENT.BRACKET_COMMENT   ;


stmt_or_function_opt_list =
    {: return new List(); :}
  | stmt_or_function_list.n {: return n; :}
  ;
stmt_or_function_list =
    stmt_or_function.n {: return new List().add(n); :}
  | stmt_or_function_list.l stmt_or_function.n {: return l.add(n); :}
  ;








else_if_clause_list =
    else_if_clause.n {: return new List().add(n); :}
  | else_if_clause_list.l else_if_clause.n {: return l.add(n); :}
  ;



function_list =
    function.n {: return new List().add(n); :}
  | function_list.l function.n {: return l.add(n); :}
  ;







class_body_opt_list =
    {: return new List(); :}
  | class_body_list.n {: return n; :}
  ;
class_body_list =
    class_body.n {: return new List().add(n); :}
  | class_body_list.l class_body.n {: return l.add(n); :}
  ;

methods_body_opt_list =
    {: return new List(); :}
  | methods_body_list.n {: return n; :}
  ;
methods_body_list =
    methods_body.n {: return new List().add(n); :}
  | methods_body_list.l methods_body.n {: return l.add(n); :}
  ;














switch_case_list =
    switch_case.n {: return new List().add(n); :}
  | switch_case_list.l switch_case.n {: return l.add(n); :}
  ;

name_list =
    name.n {: return new List().add(n); :}
  | name_list.l name.n {: return l.add(n); :}
  ;


properties_body_opt_list =
    {: return new List(); :}
  | properties_body_list.n {: return n; :}
  ;
properties_body_list =
    properties_body.n {: return new List().add(n); :}
  | properties_body_list.l properties_body.n {: return l.add(n); :}
  ;





events_body_opt_list =
    {: return new List(); :}
  | events_body_list.n {: return n; :}
  ;
events_body_list =
    events_body.n {: return new List().add(n); :}
  | events_body_list.l events_body.n {: return l.add(n); :}
  ;






























help_comment_opt_list =
    {: return new List(); :}
  | help_comment_list.n {: return n; :}
  ;
help_comment_list =
    help_comment.n {: return new List().add(n); :}
  | help_comment_list.l help_comment.n {: return l.add(n); :}
  ;









attributes_opt =
    {: return new List(); :}
  | attributes.n {: return n; :}
  ;


stmt_list =
    stmt.n {: return new List().add(n); :}
  | stmt_list.l stmt.n {: return l.add(n); :}
  ;



